# PL/0标准语法规则 (原始形式，包含左公因子和左递归)
# 参考：Niklaus Wirth的PL/0标准语法定义
# 注意：if语句保持当前形式 if (condition) statement，其他按标准PL/0

# @REQUIRE_EXPLICIT_DECLARATION: true
# 语言特性：PL/0要求变量必须先声明（使用var关键字）才能使用

# 程序结构：程序由一个块组成（标准PL/0以句点结尾，这里简化）
Program -> Block

# 块：标准PL/0的block结构
# block = [const-decl] [var-decl] {procedure-decl} statement
# 标准PL/0形式：可选的const声明，可选的var声明，0个或多个procedure声明，然后是一个statement
# 为了展示左公因子消除，这里列出所有可能的组合（会产生左公因子）
# 注意：标准PL/0的block在LL(1)解析中会有冲突，这里采用更实用的形式
# 通过明确的FIRST集区分：CONST开头、VAR开头、PROCEDURE开头、或直接是Stmt
Block -> 'CONST' ConstList 'SEMI' BlockRest | 'VAR' IDList 'SEMI' BlockRest | 'PROCEDURE' 'ID' 'SEMI' Block 'SEMI' BlockRest | Stmt
BlockRest -> 'VAR' IDList 'SEMI' ProcDeclList Stmt | ProcDeclList Stmt
# 注意：BlockRest -> ProcDeclList Stmt中，ProcDeclList可以为空
# 当ProcDeclList为空时，应该直接匹配Stmt，这通过FOLLOW集来处理
# 注意：标准PL/0的block中，statement是单个语句
# 如果需要多个语句，应该使用begin...end块或{...}块包裹

# 常量声明：const ident = number {, ident = number} ;
# 标准PL/0形式
ConstDecl -> 'CONST' ConstList 'SEMI' | 

# 常量列表：包含左公因子（ConstItem是公共前缀）
ConstList -> ConstItem ConstListTail
ConstListTail -> 'COMMA' ConstItem ConstListTail | 

# 常量项：ident = number
ConstItem -> 'ID' 'ASSIGN' 'NUM'

# 变量声明：var ident {, ident} ;
# 标准PL/0形式
VarDecl -> 'VAR' IDList 'SEMI' | 
VarDeclOpt -> 'VAR' IDList 'SEMI' | 

# 标识符列表：包含左公因子（'ID'是公共前缀）
IDList -> 'ID' IDListTail
IDListTail -> 'COMMA' 'ID' IDListTail | 

# 过程声明列表：{ procedure ident ; block ; }
# 标准PL/0形式，可以出现0次或多次
# 注意：在Block中，ProcDeclList通过'PROCEDURE'关键字明确识别
ProcDeclList -> ProcDecl ProcDeclList |  

# 过程声明：procedure ident ; block ;
ProcDecl -> 'PROCEDURE' 'ID' 'SEMI' Block 'SEMI'

# 语句：标准PL/0的statement
# statement = ident := expression | call ident | ? ident | ! expression | begin statement {; statement} end | if condition then statement | while condition do statement
# 注意：if语句保持当前形式 if (condition) statement
# 同时支持 { } 块结构（非标准PL/0，但更常用）
Stmt -> AssignStmt | CallStmt | ReadStmt | WriteStmt | BeginStmt | BlockStmt | IfStmt | WhileStmt

# 赋值语句：ident := expression
# 标准PL/0使用 :=，但这里保持 = 的形式
# 注意：为了支持常见的编程语言格式（每个语句后都有分号），语句定义包含分号
AssignStmt -> 'ID' 'ASSIGN' Expr 'SEMI'

# 过程调用语句：call ident
CallStmt -> 'CALL' 'ID' 'SEMI'

# Read语句：? ident（标准PL/0形式，这里用read）
ReadStmt -> 'READ' 'ID' 'SEMI'

# Write语句：! expression（标准PL/0形式，这里用write）
WriteStmt -> 'WRITE' 'LPAREN' Expr 'RPAREN' 'SEMI'

# Begin-End块：begin statement {; statement} end
# 标准PL/0形式
# 注意：为了支持常见的编程语言格式，每个语句后都有分号
BeginStmt -> 'BEGIN' StmtList 'END'

# 大括号块：{ statement {; statement} }（非标准PL/0，但更常用）
BlockStmt -> 'LBRACE' StmtList 'RBRACE'

# 语句列表：第一个语句，然后是可选的（分号+语句）序列
# 注意：由于每个语句已经包含分号，StmtListTail直接连接语句即可
StmtList -> Stmt StmtListTail
StmtListTail -> Stmt StmtListTail | 

# If语句：保持当前形式 if (condition) statement（非标准PL/0的if condition then statement）
IfStmt -> 'IF' 'LPAREN' Condition 'RPAREN' Stmt

# While语句：while condition do statement（标准PL/0形式，但这里用括号）
WhileStmt -> 'WHILE' 'LPAREN' Condition 'RPAREN' Stmt

# 条件表达式：标准PL/0的condition
# condition = odd expression | expression relop expression
Condition -> 'ODD' Expr | Expr RelOp Expr

# 关系操作符：标准PL/0的关系运算符
RelOp -> 'LT' | 'LE' | 'GT' | 'GE' | 'EQ' | 'NE'

# 表达式：标准PL/0的expression（左递归形式）
# expression = [+|-] term {(+|-) term}
# 标准PL/0的左递归形式：Expr -> Expr '+' Term | Expr '-' Term | Term
# 同时支持可选的+/-前缀（产生左公因子）
Expr -> 'PLUS' Term | 'MINUS' Term | Term | Expr 'PLUS' Term | Expr 'MINUS' Term 

# 项：标准PL/0的term（左递归形式）
# term = factor {(*|/) factor}
# 标准PL/0的左递归形式：Term -> Term '*' Factor | Term '/' Factor | Factor
# 包含左递归和左公因子
Term -> Term 'MUL' Factor | Term 'DIV' Factor | Factor 

# 因子：标准PL/0的factor
# factor = ident | number | ( expression )
Factor -> 'ID' | 'NUM' | 'LPAREN' Expr 'RPAREN'
